from django.contrib.auth.models import User
from django.core.exceptions import ValidationError
from django.db import models


# Core user profile extending Django's built-in User model
class Profile(models.Model):
    GENDER_CHOICES = [
        ("M", "Male"),
        ("F", "Female"),
        ("O", "Other"),
        ("P", "Prefer not to say"),
    ]

    user = models.OneToOneField(User, on_delete=models.CASCADE)
    name = models.CharField(max_length=100)
    bio = models.TextField(blank=True)
    about_me = models.TextField(blank=True, help_text="Detailed about me section")
    address = models.TextField(blank=True)
    personal_website = models.URLField(blank=True, null=True)
    gender = models.CharField(max_length=1, choices=GENDER_CHOICES, blank=True)
    profile_pic = models.ImageField(upload_to="profiles/", blank=True, null=True)
    created_at = models.DateTimeField(
        auto_now_add=True, help_text="When the user first joined"
    )

    # AI-powered features for personalized matching and recommendations
    profile_summary = models.TextField(
        blank=True,
        null=True,
        help_text="A brief summary of the user's profile generated by LLM",
    )

    users_embedding = models.TextField(
        blank=True,
        null=True,
        help_text="The user's profile embedding for recommendations generated by LLM",
    )

    # Many-to-Many relationships
    skills = models.ManyToManyField("Skill", blank=True, related_name="profiles")
    interests = models.ManyToManyField("Interest", blank=True, related_name="profiles")

    def __str__(self):
        return f"Profile of {self.user.username}"


class UserMemory(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name="memories")
    content = models.TextField(
        blank=True,
        help_text="A memory of the user's interactions with LLM for cross-conversation context",
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"Memory for {self.user.username}"


class Institution(models.Model):
    name = models.CharField(max_length=255)
    location = models.CharField(max_length=255, blank=True, null=True)
    website = models.URLField(blank=True, null=True)

    def __str__(self):
        return self.name


# Educational background with validation
class Education(models.Model):
    DEGREE_CHOICES = [
        ("associate", "Associate Degree"),
        ("bachelor", "Bachelor's Degree"),
        ("master", "Master's Degree"),
        ("doctorate", "Doctorate/PhD"),
        ("diploma", "Diploma"),
        ("certificate", "Certificate"),
        ("other", "Other"),
    ]

    profile = models.ForeignKey(
        Profile, on_delete=models.CASCADE, related_name="educations"
    )
    institution = models.ForeignKey(
        Institution,
        on_delete=models.CASCADE,
        related_name="educations",
        null=True,
        blank=True,
    )
    major = models.CharField(
        max_length=200, help_text="Field of study/Major", blank=True, null=True
    )
    degree = models.CharField(
        max_length=20,
        choices=DEGREE_CHOICES,
        help_text="Type of degree",
        null=True,
        blank=True,
    )
    series = models.CharField(
        max_length=50,
        blank=True,
        null=True,
        help_text="Series/Batch (e.g., 'Fall 2020', '21st Batch')",
    )
    start_date = models.DateField(blank=True, null=True)
    end_date = models.DateField(
        blank=True, null=True, help_text="Leave blank if currently studying"
    )
    is_current = models.BooleanField(default=False, help_text="Currently studying here")
    description = models.TextField(blank=True)

    class Meta:
        ordering = ["-start_date"]

    def clean(self):
        """Validate education data."""
        super().clean()

        # Validate date ranges
        if self.end_date and self.start_date:
            if self.end_date < self.start_date:
                raise ValidationError(
                    {"end_date": "End date cannot be before start date."}
                )

        # Current education shouldn't have end date
        if self.is_current and self.end_date:
            raise ValidationError(
                {"end_date": "Current education should not have an end date."}
            )

    def save(self, *args, **kwargs):
        """Override save to call clean."""
        self.clean()
        super().save(*args, **kwargs)

    def __str__(self):
        if self.institution:
            return f"{self.degree} in {self.major} at {self.institution.name}"
        return f"{self.degree} in {self.major}"


class Skill(models.Model):
    name = models.CharField(max_length=100, unique=True)

    class Meta:
        ordering = ["name"]

    def __str__(self):
        return self.name


class WorkOrganization(models.Model):
    name = models.CharField(max_length=255)
    location = models.CharField(max_length=255, blank=True, null=True)
    website = models.URLField(blank=True, null=True)

    def __str__(self):
        return self.name


# Work experience including jobs, volunteering, internships
class WorkExperience(models.Model):
    EXPERIENCE_TYPES = [
        ("job", "Job"),
        ("volunteering", "Volunteering"),
        ("club", "Club/Organization"),
        ("internship", "Internship"),
    ]

    profile = models.ForeignKey(
        Profile, on_delete=models.CASCADE, related_name="work_experiences"
    )
    title = models.CharField(max_length=200, help_text="Job title/designation/role")
    organization = models.ForeignKey(
        WorkOrganization,
        on_delete=models.CASCADE,
        related_name="work_experiences",
        null=True,
        blank=True,
    )
    experience_type = models.CharField(
        max_length=20, choices=EXPERIENCE_TYPES, default="job"
    )
    description = models.TextField(blank=True)
    start_date = models.DateField()
    end_date = models.DateField(
        blank=True, null=True, help_text="Leave blank if currently working"
    )
    is_current = models.BooleanField(default=False)
    skills = models.ManyToManyField(
        "Skill", blank=True, related_name="work_experiences"
    )

    class Meta:
        ordering = ["-start_date"]

    def clean(self):
        """Validate work experience data."""
        super().clean()

        # Validate date ranges
        if self.end_date and self.start_date:
            if self.end_date < self.start_date:
                raise ValidationError(
                    {"end_date": "End date cannot be before start date."}
                )
        # Current work shouldn't have end date
        if self.is_current and self.end_date:
            raise ValidationError(
                {"end_date": "Current work experience should not have an end date."}
            )

    def save(self, *args, **kwargs):
        """Override save to call clean."""
        self.clean()
        super().save(*args, **kwargs)

    def __str__(self):
        if self.organization:
            return f"{self.title} at {self.organization.name}"
        return f"{self.title} at No Organization"


# Personal and collaborative projects
class Project(models.Model):
    PROJECT_TYPES = [
        ("personal", "Personal"),
        ("collaborative", "Collaborative"),
    ]

    profile = models.ForeignKey(
        Profile, on_delete=models.CASCADE, related_name="projects"
    )
    title = models.CharField(max_length=200)
    description = models.TextField()
    project_type = models.CharField(
        max_length=20, choices=PROJECT_TYPES, default="personal"
    )
    start_date = models.DateField()
    end_date = models.DateField(
        blank=True, null=True, help_text="Leave blank if ongoing"
    )
    is_ongoing = models.BooleanField(default=False)
    project_url = models.URLField(
        blank=True, null=True, help_text="Project demo/repository link"
    )
    github_url = models.URLField(
        blank=True, null=True, help_text="GitHub repository link"
    )
    technologies = models.ManyToManyField("Skill", blank=True, related_name="projects")
    collaborators = models.ManyToManyField(
        User,
        blank=True,
        related_name="collaborated_projects",
        help_text="Other users who collaborated on this project",
    )
    associated_institution = models.ForeignKey(
        Institution,
        on_delete=models.SET_NULL,
        blank=True,
        null=True,
        related_name="projects",
    )

    class Meta:
        ordering = ["-start_date"]

    def clean(self):
        """Validate project data."""
        super().clean()

        # Validate date ranges
        if self.end_date and self.start_date:
            if self.end_date < self.start_date:
                raise ValidationError(
                    {"end_date": "End date cannot be before start date."}
                )

        # Ongoing project shouldn't have end date
        if self.is_ongoing and self.end_date:
            raise ValidationError(
                {"end_date": "Ongoing project should not have an end date."}
            )

    def save(self, *args, **kwargs):
        """Override save to call clean."""
        self.clean()
        super().save(*args, **kwargs)

    def __str__(self):
        return self.title


# Achievement model for all types of achievements
class Achievement(models.Model):
    ACHIEVEMENT_TYPES = [
        ("award", "Award/Recognition"),
        ("certification", "Certification"),
        ("competition", "Competition/Contest"),
        ("hackathon", "Hackathon"),
        ("internship", "Internship/Fellowship"),
        ("scholarship", "Scholarship"),
        ("other", "Other"),
    ]

    profile = models.ForeignKey(
        Profile, on_delete=models.CASCADE, related_name="achievements"
    )
    title = models.CharField(max_length=200)
    description = models.TextField(blank=True)
    achievement_type = models.CharField(
        max_length=20, choices=ACHIEVEMENT_TYPES, default="award"
    )
    issuer = models.CharField(max_length=200, help_text="Organization that issued this")
    date_received = models.DateField()
    url = models.URLField(
        blank=True, null=True, help_text="Link to certificate or details"
    )

    class Meta:
        ordering = ["-date_received"]

    def __str__(self):
        return f"{self.title} - {self.issuer}"


# Publication model for academic/research publications
class Publication(models.Model):
    PUBLICATION_TYPES = [
        ("journal", "Journal Paper"),
        ("conference", "Conference Paper"),
        ("thesis", "Thesis/Dissertation"),
        ("book", "Book/Chapter"),
        ("other", "Other"),
    ]

    profile = models.ForeignKey(
        Profile, on_delete=models.CASCADE, related_name="publications"
    )
    title = models.CharField(max_length=300)
    description = models.TextField(
        blank=True, help_text="Brief description of the publication"
    )
    publication_type = models.CharField(max_length=20, choices=PUBLICATION_TYPES)
    authors = models.CharField(
        max_length=500, help_text="All authors (comma separated)"
    )
    publication_date = models.DateField()
    url = models.URLField(blank=True, null=True, help_text="Link to publication")

    class Meta:
        ordering = ["-publication_date"]

    def __str__(self):
        return f"{self.title} ({self.publication_date.year})"


# Online courses and certifications
class Course(models.Model):
    profile = models.ForeignKey(
        Profile, on_delete=models.CASCADE, related_name="courses"
    )
    title = models.CharField(max_length=200)
    provider = models.CharField(max_length=200, help_text="Course provider/platform")
    description = models.TextField(blank=True)
    completion_date = models.DateField(blank=True, null=True)
    certificate_url = models.URLField(
        blank=True, null=True, help_text="Link to certificate"
    )
    skills_learned = models.ManyToManyField("Skill", blank=True, related_name="courses")
    associated_institution = models.ForeignKey(
        Institution,
        on_delete=models.SET_NULL,
        blank=True,
        null=True,
        related_name="courses",
    )

    class Meta:
        ordering = ["-completion_date"]

    def __str__(self):
        return f"{self.title} - {self.provider}"


class Interest(models.Model):
    name = models.CharField(max_length=100, unique=True)

    class Meta:
        ordering = ["name"]

    def __str__(self):
        return self.name


# User follow relationships (like Instagram/Twitter)
class Follow(models.Model):
    follower = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name="following",
        help_text="User who is following",
    )
    following = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name="followers",
        help_text="User being followed",
    )
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        # Prevent duplicate follows and self-follows
        unique_together = ("follower", "following")
        ordering = ["-created_at"]

    def clean(self):
        """Prevent users from following themselves."""
        if self.follower == self.following:
            raise ValidationError("Users cannot follow themselves.")

    def save(self, *args, **kwargs):
        """Override save to call clean."""
        self.clean()
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.follower.username} follows {self.following.username}"
